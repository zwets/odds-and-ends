#!/bin/bash
#
#  relabel-newick - relabel nodes in a newick format file
#  Copyright (C) 2017  Marco van Zwetselaar <io@zwets.it>
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#  Home: https://github.com/zwets/odds-and-ends

# Function to exit this script with an error message on stderr
err_exit() {
    echo "$(basename "$0"): $*" >&2
    exit 1
}

# Function to exit this script on parse error
parse_error() {
    err_exit "parse error${1:+: $1} at: ${TOK}${BUF}"
}

# Parser functions to traverse the tree

# Newick BNF syntax (condensed)
#
# Tree         ::= Branch ;
# Branch       ::= [(Branch [,Branch ...])] [name] [:length]

TOK=""
BUF=""

# Tokeniser - tokens are the five characters ( ) , : , or a sequence of anything else
next_Token() {
    local C="$(expr "$BUF" : '^ *\(.\?\).*')"
    case "$C" in
    '') TOK=''
        BUF=''
        ;;
    '('|','|')'|':'|';')
        TOK="$C"
        BUF="$(expr "$BUF" : '^ *.\(.*\)')"
        ;;
    *) 
        TOK="$(expr "$BUF" : '^ *\([^(,):;]\+\).*')"
        BUF="$(expr "$BUF" : '^ *[^(,):;]\+\(.*\)')"
        ;;
    esac
    true
}

# Parse and output next token "$1", erroring if it is not there
parse() {
    if [ $# -eq 0 ] || [ "$TOK" = "$1" ]; then
        printf "$TOK"
    else
        parse_error "expecting '$1'"
    fi
    next_Token
}

# Top-most level is the three (assumes next_Token has been called once)
parse_Tree() {
    parse_Branch
    parse ';'
}

parse_Branch() {
    opt_parse_List
    opt_parse_Name
    opt_parse_Length
}

opt_parse_List() {
    [ "$TOK" = '(' ] && parse '(' && parse_Branch && opt_parse_Branches && parse ')' ||
    true
}

opt_parse_Branches() {
    [ "$TOK" = ',' ] && parse ',' && parse_Branch && opt_parse_Branches || 
    true
}

opt_parse_Name() {
    expr "$TOK" : '[(,):;]' >/dev/null || {
        printf "$TOK" | sed -re "$EDIT_STRING"
        next_Token
    }
}

opt_parse_Length() {
    [ "$TOK" = ':' ] && parse ':' && parse_Length ||
    true
}

parse_Length() {
    local N="$(expr "$TOK" : '^\([0-9]\+\(\.[0-9]\+\)\?\)$')" && parse "$N" || parse_error "expected number"
}

# Function to show usage information and exit
usage_exit() {
    echo "
Usage: $(basename "$0") [OPTIONS] [FILE]

  Read newick format FILE, apply the relabeling operations specified
  on standard input and write the result to standard output.

  OPTIONS
   -v,--verbose  produce verbose output on stderr
   -h,--help     this help

  Standard input must have lines with colon-separated values OLD:NEW,
  where OLD and NEW are interpreted by sed's substitute command and
  applied in turn to each label in the Newick tree.

  Labels must not contain any of these: semicolon, comma, parentheses,
  and colon.  They may contain spaces but note that not all Newick
  processing tools tolerate whitespace.
  "
    exit ${1:-1}
}

# Parse options

while [ $# -ne 0 -a "$(expr "$1" : '\(.\).*')" = "-" ]; do
    case $1 in
    -v|--verbose)
        VERBOSE=1
        ;;
    -h|--help)
        usage_exit 0
        ;;
    *) usage_exit
        ;;
    esac
    shift
done

# Execute main

# Read the input file into buf
[ $# -eq 1 ] || usage_exit
[ -f "$1" ] || err_exit "no such file: $1"
BUF="$(cat "$1")"

# Process the instructions on standard input, each having format OLD:NEW.
while read LINE; do
    [ -n "$LINE" ] || continue
    [ $(expr index "$LINE" ',;()') -eq 0 ] || err_exit "invalid character on line (see $(basename $0) --help): $LINE"
    [ $(echo "$LINE" | sed -e 's/[^:]*//g') = ':' ] || err_exit "line must contains one colon character: $LINE"
    OLD="${LINE%%:*}"
    NEW="${LINE##*:}"
    EDIT_STRING="${EDIT_STRING:+$EDIT_STRING;}s:$OLD:$NEW:"
done

next_Token
parse_Tree
echo

# vim: sts=4:sw=4:et:ai:si
