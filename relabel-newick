#!/bin/bash
#
#  relabel-newick - relabel nodes in a newick format file
#  Copyright (C) 2017  Marco van Zwetselaar <io@zwets.it>
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#  Home: https://github.com/zwets/odds-and-ends

# Function to exit this script with an error message on stderr
err_exit() {
    echo "$(basename "$0"): $*" >&2
    exit 1
}

# Function to exit this script on parse error
parse_error() {
    err_exit "parse error${1:+: $1} at: ${TOK}${BUF}"
}

# Parser functions to traverse the tree
# - Newick BNF syntax (condensed from Wikipedia entry)
#   Tree   ::= Branch ';'
#   Branch ::= ['('Branch [','Branch ...]')'] [name] [':'length]

# Holds the current state of the parser
TOK=""
BUF=""

# Tokeniser - tokens are the five characters ( ) , : , or a sequence of anything else
next_Token() {
    local C="$(expr "$BUF" : '^ *\(.\?\).*')"
    case "$C" in
    '') TOK=''
        BUF=''
        ;;
    '('|','|')'|':'|';')
        TOK="$C"
        BUF="$(expr "$BUF" : '^ *.\(.*\)')"
        ;;
    *)
        TOK="$(expr "$BUF" : '^ *\([^(,):;]\+\).*')"
        BUF="$(expr "$BUF" : '^ *[^(,):;]\+\(.*\)')"
        ;;
    esac
    true
}

# Try and parse next token, which if $1 is given, must equal $1, else false
try_parse() {
    [ $# -ne 1 ] || [ "$TOK" = "$1" ] || return 1
    printf "$TOK"
    next_Token
}

parse_Tree() {
    parse_Branch
    parse_Char ';'
}

parse_Branch() {
    opt_parse_List
    opt_parse_Name
    opt_parse_Length
}

opt_parse_List() {
    try_parse '(' && parse_Branch && opt_parse_Branches && parse_Char ')' ||
    true
}

opt_parse_Branches() {
    try_parse ',' && parse_Branch && opt_parse_Branches ||
    true
}

opt_parse_Name() {
    expr "$TOK" : '[^(,):;]*' >/dev/null && printf "$TOK" | sed -re "$EDIT_STRING" && next_Token ||
    true
}

opt_parse_Length() {
    try_parse ':' && parse_Length ||
    true
}

parse_Length() {
    expr "$TOK" : '^\([0-9]\+\(\.[0-9]\+\)\?\)$' >/dev/null && printf "$TOK" && next_Token ||
    parse_error "expected number"
}

parse_Char() {
    try_parse "$1" || parse_error "expecting '$1'"
}

# Function to show usage information and exit
usage_exit() {
    echo "
Usage: $(basename "$0") [OPTIONS] FILE

  Read newick format FILE, apply the relabeling operations specified
  on standard input, and write the result to standard output.

  OPTIONS
   -v,--verbose  produce verbose output on stderr
   -h,--help     this help

  Standard input must have lines with colon-separated values OLD:NEW,
  where OLD and NEW are interpreted by sed's substitute command.  OLD
  is a modern regex(7) that will be matched against each node label in
  turn.  The first match is replaced by NEW.  NEW may contain back
  references, and it may be suffixed with ':g' for global find/replace.

  Labels must not contain any of these: semicolon, comma, parentheses,
  and colon.  They may contain spaces but note that not all Newick
  processing tools tolerate whitespace.

  EXAMPLES
  $ echo '[0-9]\+:' | $(basename "$0") file.newick
    removes the first occurring number from every label
  $ echo '([0-9]\+):X\1:g' | ...
    prepends X to every number in every label
  $ echo '^([0-9]\+)$:NR\1' | ...
    prepends NR to every label that is entirely numeric
  "
    exit ${1:-1}
}

# Parse options

while [ $# -ne 0 -a "$(expr "$1" : '\(.\).*')" = "-" ]; do
    case $1 in
    -v|--verbose) VERBOSE=1 ;;
    -h|--help) usage_exit 0 ;;
    *) usage_exit ;;
    esac
    shift
done

# Main

# Read the input file into buf
[ $# -eq 1 ] || usage_exit
[ -f "$1" ] || err_exit "no such file: $1"
BUF="$(cat "$1")"

# Process the instructions on standard input, appending them to a sed 'program'
while read LINE; do
    [ -n "$LINE" ] || continue
    expr "$LINE" : '.*:' >/dev/null ||
        err_exit "line contains no colon character: $LINE"
    OLD="${LINE%%:*}"
    NEW="${LINE##*:}"
    EDIT_STRING="${EDIT_STRING:+$EDIT_STRING;}s:$OLD:$NEW:g"
done

# Do the actual work
next_Token
parse_Tree
echo

# vim: sts=4:sw=4:et:ai:si
